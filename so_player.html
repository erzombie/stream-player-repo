<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>SO Player</title>
<style>
  :root{
    --radius:16px;
    --bannerBg: rgba(32,32,32,.92);
    --bannerText:#fff;
    --muted:#d6d6d6;
    --shadow: 0 14px 38px rgba(0,0,0,.35);
    /* how much the VIDEO should “overscan” into the border (GIFs not affected) */
    --overscan: 4%;
  }

  html,body{height:100%; width:100%; margin:0; background:transparent; overflow:hidden; font-family:system-ui,Segoe UI,Roboto,Inter,Arial,sans-serif;}
  #stage{position:fixed; inset:0; background:transparent;}

  /* Video box */
  #playerBox{
    position:absolute;
    left:50%;
    top:6vh;
    transform:translateX(-50%);
    width:min(92vw, 160vh);
    height:min(78vh, 51.75vw);
    border-radius:var(--radius);
    overflow:hidden;
    background:rgba(0,0,0,.65);
    box-shadow: var(--shadow);
    display:flex; align-items:center; justify-content:center;
  }

  /* the three possible renderers live inside #player */
  #player{ position:relative; width:100%; height:100%; }
  #twitch, #clipFrame, #gif{ width:100%; height:100%; }

  /* overscan ONLY the video players so rounded corners are visible in OBS */
  #twitch{ position:absolute; inset:0; }
  #twitch iframe{
    position:absolute !important;
    left:calc(-1 * var(--overscan));
    top:calc(-1 * var(--overscan));
    width:calc(100% + var(--overscan) * 2);
    height:calc(100% + var(--overscan) * 2);
    border:0;
  }

  #clipFrame{
    position:absolute;
    left:calc(-1 * var(--overscan));
    top:calc(-1 * var(--overscan));
    width:calc(100% + var(--overscan) * 2);
    height:calc(100% + var(--overscan) * 2);
    border:0;
    display:none;
  }

  /* GIF stays unscaled to avoid pixelation */
  #gif{ display:none; object-fit:contain; background:transparent; }

  /* Bottom banner */
  #banner{
    position:absolute; left:50%; bottom:4.5vh; transform:translateX(-50%);
    display:flex; align-items:center; gap:clamp(12px, 1.8vw, 28px);
    padding:clamp(14px, 1.4vw, 26px) clamp(18px, 2.2vw, 34px);
    background:var(--bannerBg);
    color:var(--bannerText);
    border-radius:14px;
    box-shadow: var(--shadow);
    max-width:min(88vw, 1400px);
    pointer-events:none;
  }

  /* Bigger avatar circle, image snaps to the circle */
  #avatarWrap{
    width:clamp(64px, 8vw, 112px);
    height:clamp(64px, 8vw, 112px);
    border-radius:999px;
    overflow:hidden;
    border:clamp(2px, .5vw, 4px) solid rgba(0,0,0,.35);
    box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
    flex:0 0 auto;
  }
  #avatar{
    width:100%; height:100%;
    object-fit:cover;             /* fills the circle without squishing */
    display:block;
  }

  #name{
    font-weight:900;
    font-size:clamp(28px, 4vw, 64px);
    line-height:1.05; letter-spacing:.2px;
  }

  #tag{
    font-size:clamp(16px, 2vw, 28px);
    color:var(--muted);
    margin-top:clamp(2px, .3vw, 6px);
  }

  #textCol{ display:flex; flex-direction:column; }
</style>
</head>
<body>
<div id="stage">
  <div id="playerBox">
    <div id="player">
      <!-- VOD uses #twitch via JS Embed; clip uses #clipFrame; gif uses #gif -->
      <div id="twitch" style="width:100%;height:100%;display:none;"></div>
      <iframe id="clipFrame" style="display:none;" allow="autoplay; fullscreen"></iframe>
      <img id="gif" alt="so-fallback" />
    </div>
  </div>

  <div id="banner" role="complementary" aria-live="polite">
    <div id="avatarWrap"><img id="avatar" src="" alt="avatar"></div>
    <div id="textCol">
      <div id="name">Friend</div>
      <div id="tag">Check out Friend!</div>
    </div>
  </div>
</div>

<script>
(function(){
  /* ---------- tolerant param parser + debug ---------- */
  const qs = new URLSearchParams(location.search);
  const ALIAS = {
    name:    ['name','displayName','user','username','target'],
    profile: ['profile','avatar','pfp','image','img'],
    clip:    ['clip','clipId','slug'],
    vod:     ['vod','video','videoId'],
    vodStart:['vodStart','start','time'],
    gif:     ['gif','fallback','fallbackGif'],
    vol:     ['vol','volume'],
    dur:     ['dur','duration','ms'],
    text:    ['text','banner','subtitle'],
    debug:   ['debug']
  };
  const unresolved = v => /^%.*%$/.test(v || '');
  function getParam(key, def=''){
    for (const k of (ALIAS[key]||[key])) {
      if (qs.has(k)) {
        const v = qs.get(k);
        return unresolved(v) ? def : (v ?? def);
      }
    }
    return def;
  }
  function getNum(key, def){
    const v = parseFloat(getParam(key,'')); 
    return Number.isFinite(v) ? v : def;
  }
  function debugBox(text){
    if (!getParam('debug')) return;
    const pre = document.createElement('pre');
    pre.style.cssText = 'position:fixed;right:8px;top:8px;z-index:99999;background:#101420;color:#9fe;border:1px solid #30394a;border-radius:8px;padding:10px 12px;font:12px ui-monospace,Consolas,monospace;max-width:42vw;white-space:pre-wrap;backdrop-filter:blur(6px)';
    pre.textContent = text;
    document.body.appendChild(pre);
  }

  const P = {
    name:    getParam('name','Friend'),
    profile: getParam('profile',''),
    clip:    getParam('clip',''),
    vod:     getParam('vod',''),
    vodStart:getParam('vodStart',''),
    gif:     getParam('gif',''),
    vol:     Math.max(0, Math.min(1, getNum('vol', 0.35))),
    // 12s when we have video (clip/vod), else 6s for GIF
    dur:     (()=>{ const d=parseInt(getParam('dur',''),10);
                    if (Number.isFinite(d) && d>0) return d;
                    return (getParam('clip')||getParam('vod')) ? 12000 : 6000; })(),
    text:    getParam('text','')
  };

  debugBox(`[PARAMS]
name=${P.name}
profile=${P.profile}
clip=${P.clip}
vod=${P.vod}
gif=${P.gif||'(none)'}
vol=${P.vol}
dur=${P.dur}
text=${P.text||'(auto)'}`);

  /* ---------- banner text + avatar ---------- */
  document.getElementById('name').textContent = P.name;
  document.getElementById('tag').textContent  = P.text || `Check out ${P.name}!`;
  if (P.profile) document.getElementById('avatar').src = P.profile;

  /* ---------- parent list for Twitch embeds ---------- */
  const host = (location.hostname || 'localhost');
  const parents = [host, 'localhost', '127.0.0.1'].filter((v,i,a)=>v && a.indexOf(v)===i);
  const parentQS = parents.map(p => 'parent=' + encodeURIComponent(p)).join('&');

  /* ---------- elements ---------- */
  const twDiv = document.getElementById('twitch');
  const clipI = document.getElementById('clipFrame');
  const gif   = document.getElementById('gif');

  /* ---------- random GIF pool (FIXED COMMAS) ---------- */
  const gifPool = [
    '/stream-player-repo/assets/hellothere.gif',
    '/stream-player-repo/assets/hellothere2.gif',
    '/stream-player-repo/assets/blinkguy.gif',
    '/stream-player-repo/assets/bocchi.gif',
    '/stream-player-repo/assets/elmo.gif',
    '/stream-player-repo/assets/lick-anime.gif'
  ];
  function pickGif(arg){
    if (!arg || arg === 'random') {
      return gifPool[Math.floor(Math.random()*gifPool.length)];
    }
    return arg;
  }
  function showGif(arg){
    const src = pickGif(arg);
    gif.src = src;
    gif.style.display   = 'block';
    clipI.style.display = 'none';
    twDiv.style.display = 'none';
  }

  /* ---------- timer ---------- */
  let hideTimer = null;
  function startTimer(ms){
    if (hideTimer) clearTimeout(hideTimer);
    hideTimer = setTimeout(()=>{ /* Streamer.bot hides the source */ }, ms);
  }

 <script>
(function(){
  /* …everything above stays the same… */

  // --- Priority: VOD > Clip > GIF ---
  if (P.vod) {
    const s = document.createElement('script');
    s.src = 'https://player.twitch.tv/js/embed/v1.js';
    s.onload = () => {
      try {
        const OBS = !!window.obsstudio;
        const wantVol = Math.max(0, Math.min(1, P.vol || 0));

        const embed = new Twitch.Embed('twitch', {
          width: '100%',
          height: '100%',
          video: P.vod,
          time: P.vodStart ? `0h0m${parseInt(P.vodStart,10)||0}s` : undefined,
          autoplay: true,
          muted: true,                // start muted so autoplay is allowed
          allowfullscreen: true,
          parent: parents
        });

        twDiv.style.display = 'block';
        clipI.style.display = 'none';
        gif.style.display   = 'none';

        let ready = false;
        embed.addEventListener(Twitch.Embed.VIDEO_READY, () => {
          ready = true;
          try {
            const player = embed.getPlayer();
            player.setMuted(true);
            player.setVolume(0);
            player.play();
            if (wantVol > 0) {
              setTimeout(() => {
                try {
                  if (OBS) player.setMuted(false);     // browsers may ignore
                  player.setVolume(wantVol);
                } catch {}
              }, 600);
            }
          } catch {}
          startTimer(P.dur);
        });

        // If Twitch never gets ready (blocked), fall back to GIF
        setTimeout(() => { if (!ready) { showGif(P.gif || 'random'); startTimer(6000); } }, 1800);
      } catch {
        showGif(P.gif || 'random'); startTimer(6000);
      }
    };
    s.onerror = () => { showGif(P.gif || 'random'); startTimer(6000); };
    document.body.appendChild(s);
  }
  else if (P.clip) {
    const url =
      `https://clips.twitch.tv/embed?clip=${encodeURIComponent(P.clip)}&autoplay=true&muted=true` +
      (parentQS ? `&${parentQS}` : '');
    clipI.src = url;
    clipI.allow = 'autoplay; fullscreen; picture-in-picture';
    clipI.setAttribute('playsinline', 'true');
    clipI.setAttribute('allowtransparency', 'true');

    clipI.style.display = 'block';
    twDiv.style.display = 'none';
    gif.style.display   = 'none';

    startTimer(P.dur);
  }
  else {
    showGif(P.gif || 'random');
    startTimer(6000);
  }
})();
</script>

</body>
</html>
