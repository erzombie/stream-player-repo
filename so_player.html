<!doctype html>
<meta charset="utf-8" />
<title>SO Player</title>
<style>
  :root { --pad: 16px; }
  html,body{height:100%;margin:0;background:transparent;overflow:hidden}
  #wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center}
  #player{position:absolute;inset:0;}
  #fallback{position:absolute;inset:0;display:none;align-items:flex-end;justify-content:flex-start}
  #fallback.show{display:flex}
  #bar{
    width:100%;margin:0 var(--pad) var(--pad) var(--pad);
    padding:12px 16px;border-radius:14px;background:rgba(0,0,0,.65);
    color:#fff;font:600 32px/1.2 system-ui,Segoe UI,Roboto,Arial,sans-serif;
    display:flex;align-items:center;gap:14px;
  }
  #avatar{
    width:56px;height:56px;border-radius:50%;flex:0 0 56px;object-fit:cover;
    background:#222
  }
</style>

<div id="wrap">
  <div id="player"></div>

  <!-- fallback banner if we can't play a clip -->
  <div id="fallback">
    <div id="bar">
      <img id="avatar" alt="">
      <div id="who"></div>
    </div>
  </div>
</div>

<!-- Twitch embed API (lets us set volume and unmute after load) -->
<script src="https://embed.twitch.tv/embed/v1.js"></script>
<script>
(function () {
  const qs = new URLSearchParams(location.search);

  const name   = qs.get('name')   || '';
  const avatar = qs.get('avatar') || '';
  const vol    = Math.max(0, Math.min(1, parseFloat(qs.get('vol') || '0.3') || 0));
  const text   = qs.get('text')   || (name ? `Check out ${name}!` : 'Check them out!');
  const parent = location.hostname;

  // Accept clipId directly, or a 'clip' full URL, or even a raw slug.
  const clipId = qs.get('clipId') || parseClip(qs.get('clip') || '');

  // UI wiring
  const fallback = document.getElementById('fallback');
  const who      = document.getElementById('who');
  const img      = document.getElementById('avatar');
  who.textContent = text;
  if (avatar) img.src = avatar;

  function showFallback(){ fallback.classList.add('show'); }

  // Try to embed the clip
  if (clipId) {
    let ready = false;
    try {
      const player = new Twitch.Player("player", {
        width: "100%", height: "100%",
        clip: clipId,
        autoplay: true,
        muted: (vol <= 0),          // keep muted for autoplay, we unmute on READY if vol>0
        controls: false,
        parent: [parent]
      });

      player.addEventListener(Twitch.Player.READY, function () {
        ready = true;
        try {
          player.setVolume(vol);
          if (vol > 0) player.setMuted(false);
        } catch(_) {}
      });

      // If the embed never becomes ready, fall back gracefully
      setTimeout(function(){ if(!ready) showFallback(); }, 2500);
    } catch (e) {
      showFallback();
    }
  } else {
    showFallback();
  }

  // --- helpers ---
  function parseClip(input){
    if (!input) return '';
    // already a slug?
    if (/^[A-Za-z0-9_-]+$/.test(input)) return input;

    try {
      const u = new URL(input);

      // ?clip=<slug>
      const qp = u.searchParams.get('clip');
      if (qp) return qp;

      // /clip/<slug>
      const m1 = u.pathname.match(/\/clip\/([^/?#]+)/i);
      if (m1) return m1[1];

      // clips.twitch.tv/<slug>
      if (u.hostname.includes('clips.twitch.tv')) {
        const slug = u.pathname.replace(/^\/+/, '').split(/[/?#]/)[0];
        if (slug) return slug;
      }
    } catch (_) {}

    return '';
  }
})();
</script>
