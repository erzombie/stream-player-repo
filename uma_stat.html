<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Uma Stat Overlay</title>
  <style>
    :root {
      --uma: #ffb74d; /* Uma orange */
      --tileH: 64px; /* tile height */
      --stroke: rgba(0,0,0,.65);
      --font: 'Roboto', system-ui, -apple-system, "Segoe UI", Arial, sans-serif;
      --shadow: 0 10px 28px rgba(0,0,0,.35);
    }
    html,body { margin:0; height:100%; background:transparent; overflow:hidden; }
    #stage { position:relative; width:100vw; height:100vh; pointer-events:none; }

    .popup { position:absolute; display:flex; align-items:center; gap:.44rem; filter:drop-shadow(var(--shadow)); }

    .badge { position:relative; padding: 14px 22px; overflow:visible; }
    .badge::before, .badge::after { content:""; position:absolute; left:0; top:0; width:100%; height:var(--tileH); border-radius:12px; }
    .badge::before { background:#fff; z-index:0; }
    .badge::after  { background: var(--uma); z-index:1;
      clip-path: polygon(0% 28%, 50% 0%, 100% 28%, 100% 100%, 0% 100%);
    }

    .chip { position:relative; z-index:2; font:900 42px/1 var(--font); color:#fff; letter-spacing:.4px; -webkit-text-stroke: 3px var(--stroke); text-shadow:0 2px 0 rgba(0,0,0,.35); }
    .chip .plus { margin-right:.18em; }
    .chip .stat { margin-left:.28em; }

    @keyframes riseFade {
      0%   { transform: translateY(0) scale(.96); opacity:0; }
      8%   { opacity:1; }
      70%  { transform: translateY(-90px) scale(1.02); opacity:1; }
      100% { transform: translateY(-150px) scale(1); opacity:0; }
    }
    .anim { animation: riseFade var(--dur, 1600ms) cubic-bezier(.2,.9,.2,1) forwards; }
  </style>
</head>
<body>
  <div id="stage"></div>
  <audio id="sfx" preload="auto"></audio>

  <script>
  /* Batch-capable Uma stat overlay */
  const qs = new URLSearchParams(location.search);
  const STAT_POOL = ['Speed','Stamina','Power','Guts','Wit'];

  const cfg = {
    mode: qs.get('mode') || '',
    stat: qs.get('stat') || 'Wit',
    amount: qs.has('amount') ? parseInt(qs.get('amount')||'1',10) : null,
    count: Math.max(1, Math.min(5, parseInt(qs.get('count')||'1',10))),
    concurrent: Math.max(1, Math.min(2, parseInt(qs.get('concurrent')||'2',10))),
    dur: parseInt(qs.get('dur') || '1600', 10),
    sound: qs.get('sound') || '',
    minDelay: parseInt(qs.get('minDelay') || '60', 10),
    maxDelay: parseInt(qs.get('maxDelay') || '220', 10)
  };

  switch (cfg.mode) {
    case 'v1_wit5': cfg.stat='Wit'; cfg.amount=1; cfg.count=5; cfg.concurrent=2; break;
    case 'v2_guts5': cfg.stat='Guts'; cfg.amount=1; cfg.count=5; cfg.concurrent=2; break;
    case 'v3_wit1': cfg.stat='Wit'; cfg.amount=1; cfg.count=1; cfg.concurrent=1; break;
    case 'v4_random': cfg.count = Math.floor(Math.random()*5)+1; cfg.concurrent=2; break;
  }

  const stage = document.getElementById('stage');
  const sfxEl = document.getElementById('sfx');
  if (cfg.sound) sfxEl.src = cfg.sound;

  const rand = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
  const choice = arr=>arr[Math.floor(Math.random()*arr.length)];

  function spawnOne({stat, amount, dur, sound}){
    const wrap = document.createElement('div');
    wrap.className = 'popup anim';
    wrap.style.setProperty('--dur', `${dur}ms`);
    const margin = 100;
    const x = rand(margin, window.innerWidth - margin - 260);
    const y = rand(margin+50, window.innerHeight - margin);
    wrap.style.left = x+'px';
    wrap.style.top  = y+'px';

    const badge = document.createElement('div');
    badge.className = 'badge';
    const chip = document.createElement('div');
    chip.className = 'chip';
    chip.innerHTML = `<span class="plus">+${amount}</span><span class="stat">${stat}</span>`;
    badge.appendChild(chip);
    wrap.appendChild(badge);
    stage.appendChild(wrap);

    if (sound) { try{ sfxEl.currentTime=0; sfxEl.play().catch(()=>{});}catch(e){} }

    setTimeout(()=>wrap.remove(), dur+120);
  }

  async function batchSpawn(){
    const total = cfg.count;
    const fixedAmount = cfg.amount ?? null;
    const jobs = [];
    for (let i=0;i<total;i++){
      jobs.push({
        stat: (cfg.mode==='v4_random') ? choice(STAT_POOL) : cfg.stat,
        amount: (fixedAmount==null && cfg.mode==='v4_random') ? rand(1,20) : (fixedAmount ?? 1),
        delay: rand(cfg.minDelay, cfg.maxDelay)
      });
    }

    let inFlight=0, idx=0;
    return new Promise(resolve=>{
      function tryStart(){
        while(inFlight<cfg.concurrent && idx<jobs.length){
          const j = jobs[idx++]; inFlight++;
          setTimeout(()=>{
            spawnOne({stat:j.stat, amount:j.amount, dur:cfg.dur, sound:cfg.sound});
            setTimeout(()=>{ inFlight--; tryStart(); if(idx===jobs.length && inFlight===0) resolve(); }, cfg.dur+150);
          }, j.delay);
        }
      }
      tryStart();
    });
  }

  (async()=>{ await batchSpawn(); })();
  </script>
</body>
</html>
