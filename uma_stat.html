<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Uma Stat Overlay</title>
  <style>
    :root {
      /* Locked Uma-style orange */
      --uma: #ffb74d; /* tweak if you prefer */
      --stroke: rgba(0,0,0,.65);
      --font: 'Roboto', system-ui, -apple-system, "Segoe UI", Arial, sans-serif;
      --shadow: 0 10px 28px rgba(0,0,0,.35);
    }
    html,body { margin:0; height:100%; background:transparent; overflow:hidden; }
    #stage { position:relative; width:100vw; height:100vh; pointer-events:none; }

    /* single popup container */
    .popup { position:absolute; display:flex; align-items:center; gap:.44rem; filter:drop-shadow(var(--shadow)); }

    /* badge (arrow background) */
    .badge { position:relative; padding:.28rem .56rem .32rem .56rem; }
    .badge::before, .badge::after {
      content:""; position:absolute; inset:0; border-radius:.6rem;
      background: white; opacity:1; transform: translateY(0);
    }
    .badge::after { /* orange up chevron */
      inset: 6px; border-radius:.5rem; background: var(--uma);
      clip-path: polygon(0% 30%, 100% 30%, 100% 100%, 0% 100%, 0% 30%, 50% 0%);
    }

    /* text styling */
    .chip { position:relative; font:900 42px/1 var(--font); color:#fff; letter-spacing:.4px;
            -webkit-text-stroke: 3px var(--stroke); text-shadow:0 2px 0 rgba(0,0,0,.35); }
    .chip .plus { color:#fff; margin-right:.18em; }
    .chip .stat { font-weight:800; margin-left:.28em; color:#fff; }

    /* float-up + fade */
    @keyframes riseFade {
      0%   { transform: translateY(0) scale(.96); opacity:0; }
      8%   { opacity:1; }
      70%  { transform: translateY(-90px) scale(1.02); opacity:1; }
      100% { transform: translateY(-150px) scale(1); opacity:0; }
    }
    .anim { animation: riseFade var(--dur, 1600ms) cubic-bezier(.2,.9,.2,1) forwards; }

    /* optional background video/image behind badge */
    .bgWrap { position:absolute; inset:-12px -16px -16px -16px; z-index:-1; opacity:.95; }
    .bgWrap video, .bgWrap img { width:100%; height:100%; object-fit:cover; border-radius:.6rem; filter: saturate(1.1) contrast(1.05); }
  </style>
</head>
<body>
  <div id="stage"></div>
  <audio id="sfx" preload="auto"></audio>

  <script>
  /**
   * UMA-STYLE STAT POPUP OVERLAY (Batch-capable)
   *
   * Use as a Browser Source. Trigger by changing the URL (and refreshing) from Streamer.bot.
   *
   * URL Params (examples):
   *   ?stat=Wit&amount=1&count=5&concurrent=2&dur=1600
   *   ?mode=v1_wit5        (alias for Wit +1 x5 with concurrency 2)
   *   ?mode=v2_guts5       (alias for Guts +1 x5)
   *   ?mode=v3_wit1        (alias for single Wit +1)
   *   ?mode=v4_random      (alias for random 1-5 instances, random stat, 1-20 amount each)
   * Optional:
   *   &sound=stat_up.mp3   (per-instance sfx)
   *   &bgImage=file:///C:/.../arrow.png  OR &bgVideo=file:///C:/.../spark.mp4
   *   &minDelay=200&maxDelay=600  (ms between spawns)
   */

  const qs = new URLSearchParams(location.search);

  const STAT_POOL = [ 'Speed', 'Stamina', 'Power', 'Guts', 'Wit' ];

  const cfg = {
    mode: qs.get('mode') || '',
    stat: qs.get('stat') || 'Wit',
    amount: qs.has('amount') ? parseInt(qs.get('amount')||'1',10) : null,
    count: Math.max(1, Math.min(5, parseInt(qs.get('count')||'1',10))),
    concurrent: Math.max(1, Math.min(2, parseInt(qs.get('concurrent')||'2',10))),
    dur: parseInt(qs.get('dur') || '1600', 10),
    sound: qs.get('sound') || '',
    bgImage: qs.get('bgImage') || '',
    bgVideo: qs.get('bgVideo') || '',
    minDelay: parseInt(qs.get('minDelay') || '200', 10),
    maxDelay: parseInt(qs.get('maxDelay') || '700', 10)
  };

  // Mode aliases
  switch (cfg.mode) {
    case 'v1_wit5':
      cfg.stat='Wit'; cfg.amount=1; cfg.count=5; cfg.concurrent=2; break;
    case 'v2_guts5':
      cfg.stat='Guts'; cfg.amount=1; cfg.count=5; cfg.concurrent=2; break;
    case 'v3_wit1':
      cfg.stat='Wit'; cfg.amount=1; cfg.count=1; cfg.concurrent=1; break;
    case 'v4_random':
      cfg.count = Math.floor(Math.random()*5)+1; // 1-5
      cfg.concurrent = 2;
      break;
  }

  const stage = document.getElementById('stage');
  const sfxEl = document.getElementById('sfx');
  if (cfg.sound) sfxEl.src = cfg.sound;

  function rand(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }
  function choice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  // Spawn a single popup
  function spawnOne({stat, amount, dur, sound, bgImage, bgVideo}){
    // container positioned randomly, with safe margins
    const wrap = document.createElement('div');
    wrap.className = 'popup anim';
    wrap.style.setProperty('--dur', `${dur}ms`);
    const margin = 80; // safe margin from edges
    const x = rand(margin, window.innerWidth - margin - 200); // estimate width
    const y = rand(margin+60, window.innerHeight - margin);
    wrap.style.left = x + 'px';
    wrap.style.top  = y + 'px';

    // badge background (white tile + orange chevron)
    const badge = document.createElement('div');
    badge.className = 'badge';

    // optional media background
    if (bgVideo) {
      const vwrap = document.createElement('div'); vwrap.className='bgWrap';
      const v = document.createElement('video'); v.src = bgVideo; v.autoplay = true; v.muted = true; v.playsInline = true; v.onended = ()=>{};
      vwrap.appendChild(v); badge.appendChild(vwrap);
    } else if (bgImage) {
      const iwrap = document.createElement('div'); iwrap.className='bgWrap';
      const img = document.createElement('img'); img.src = bgImage; iwrap.appendChild(img); badge.appendChild(iwrap);
    }

    const chip = document.createElement('div');
    chip.className = 'chip';
    chip.innerHTML = `<span class="plus">+${amount}</span><span class="stat">${stat}</span>`;

    badge.appendChild(chip);
    wrap.appendChild(badge);
    stage.appendChild(wrap);

    // sound per instance
    if (sound) { try { sfxEl.currentTime = 0; sfxEl.play().catch(()=>{}); } catch(e){} }

    // cleanup
    setTimeout(()=>wrap.remove(), dur + 120);
  }

  // Batch spawner with concurrency cap
  async function batchSpawn(){
    const jobs = [];
    const total = cfg.count;

    // fixed amount rule: if cfg.amount is null and mode is v4_random â†’ each instance gets 1-20
    // otherwise use the same amount for all instances
    const fixedAmount = cfg.amount ?? null;

    for (let i=0;i<total;i++) {
      jobs.push({
        stat: (cfg.mode==='v4_random') ? choice(STAT_POOL) : cfg.stat,
        amount: (fixedAmount==null && cfg.mode==='v4_random') ? rand(1,20) : (fixedAmount ?? 1),
        delay: rand(cfg.minDelay, cfg.maxDelay),
      });
    }

    let inFlight = 0; let idx = 0;

    return new Promise(resolve => {
      function tryStart(){
        while (inFlight < cfg.concurrent && idx < jobs.length) {
          const j = jobs[idx++]; inFlight++;
          setTimeout(() => {
            spawnOne({ stat:j.stat, amount:j.amount, dur:cfg.dur, sound:cfg.sound, bgImage:cfg.bgImage, bgVideo:cfg.bgVideo });
            setTimeout(()=>{ inFlight--; tryStart(); if (idx===jobs.length && inFlight===0) resolve(); }, cfg.dur+150);
          }, j.delay);
        }
      }
      tryStart();
    });
  }

  // Auto-run once per load
  (async () => { await batchSpawn(); })();
  </script>
</body>
</html>
